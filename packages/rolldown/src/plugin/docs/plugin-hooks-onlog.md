Note that unlike other plugin hooks that add e.g. the plugin name to the log, those functions will not add or change properties of the log. Additionally, logs generated by an `onLog` hook will not be passed back to
the `onLog` hook of the same plugin. If another plugin generates a log in response to such a log in its own `onLog` hook, this log will not be passed to the original `onLog` hook, either.

#### Example

```js
function plugin1() {
  return {
    name: 'plugin1',
    buildStart() {
      this.info({ message: 'Hey', pluginCode: 'SPECIAL_CODE' });
    },
    onLog(level, log) {
      if (log.plugin === 'plugin1' && log.pluginCode === 'SPECIAL_CODE') {
        // We turn logs into warnings based on their code. This warnings
        // will not be passed back to the same plugin to avoid an
        // infinite loop, but other plugins will still receive it.
        this.warn(log);
        return false;
      }
    },
  };
}

function plugin2() {
  return {
    name: 'plugin2',
    onLog(level, log) {
      if (log.plugin === 'plugin1' && log.pluginCode === 'SPECIAL_CODE') {
        // You can modify logs in this hooks as well
        log.meta = 'processed by plugin 2';
        // This turns the log back to "info". If this happens in
        // response to the first plugin, it will not be passed back to
        // either plugin to avoid an infinite loop. If both plugins are
        // active, the log will be an info log if the second plugin is
        // placed after the first one
        this.info(log);
        return false;
      }
    },
  };
}
```
