// This file is based on the Levenshtein algorithm. Originally from Koen but maybe he
// got it from somewhere else.
const peq=new Uint32Array(65536);const myers_32=(a,b)=>{const n=a.length;const m=b.length;const lst=1<<n-1;let pv=-1;let mv=0;let sc=n;let i=n;while(i--){peq[a.charCodeAt(i)]|=1<<i;}for(i=0;i<m;i++){let eq=peq[b.charCodeAt(i)];const xv=eq|mv;eq|=(eq&pv)+pv^pv;mv|=~(eq|pv);pv&=eq;if(mv&lst){sc++;}if(pv&lst){sc--;}mv=mv<<1|1;pv=pv<<1|~(xv|mv);mv&=xv;}i=n;while(i--){peq[a.charCodeAt(i)]=0;}return sc;};const myers_x=(b,a)=>{const n=a.length;const m=b.length;const mhc=[];const phc=[];const hsize=Math.ceil(n/32);const vsize=Math.ceil(m/32);for(let i=0;i<hsize;i++){phc[i]=-1;mhc[i]=0;}let j=0;for(;j<vsize-1;j++){let mv=0;let pv=-1;const start=j*32;const vlen=Math.min(32,m)+start;for(let k=start;k<vlen;k++){peq[b.charCodeAt(k)]|=1<<k;}for(let i1=0;i1<n;i1++){const eq=peq[a.charCodeAt(i1)];const pb=phc[i1/32|0]>>>i1&1;const mb=mhc[i1/32|0]>>>i1&1;const xv=eq|mv;const xh=((eq|mb)&pv)+pv^pv|eq|mb;let ph=mv|~(xh|pv);let mh=pv&xh;if(ph>>>31^pb){phc[i1/32|0]^=1<<i1;}if(mh>>>31^mb){mhc[i1/32|0]^=1<<i1;}ph=ph<<1|pb;mh=mh<<1|mb;pv=mh|~(xv|ph);mv=ph&xv;}for(let k1=start;k1<vlen;k1++){peq[b.charCodeAt(k1)]=0;}}let mv1=0;let pv1=-1;const start1=j*32;const vlen1=Math.min(32,m-start1)+start1;for(let k2=start1;k2<vlen1;k2++){peq[b.charCodeAt(k2)]|=1<<k2;}let score=m;for(let i2=0;i2<n;i2++){const eq1=peq[a.charCodeAt(i2)];const pb1=phc[i2/32|0]>>>i2&1;const mb1=mhc[i2/32|0]>>>i2&1;const xv1=eq1|mv1;const xh1=((eq1|mb1)&pv1)+pv1^pv1|eq1|mb1;let ph1=mv1|~(xh1|pv1);let mh1=pv1&xh1;score+=ph1>>>m-1&1;score-=mh1>>>m-1&1;if(ph1>>>31^pb1){phc[i2/32|0]^=1<<i2;}if(mh1>>>31^mb1){mhc[i2/32|0]^=1<<i2;}ph1=ph1<<1|pb1;mh1=mh1<<1|mb1;pv1=mh1|~(xv1|ph1);mv1=ph1&xv1;}for(let k3=start1;k3<vlen1;k3++){peq[b.charCodeAt(k3)]=0;}return score;};const distance=(a,b)=>{if(a.length<b.length){const tmp=b;b=a;a=tmp;}if(b.length===0){return a.length;}if(a.length<=32){return myers_32(a,b);}return myers_x(a,b);};const closest=(str,arr)=>{let min_distance=Infinity;let min_index=0;for(let i=0;i<arr.length;i++){const dist=distance(str,arr[i]);if(dist<min_distance){min_distance=dist;min_index=i;}}return arr[min_index];};export{closest,distance};
export const __FramerMetadata__ = {"exports":{"closest":{"type":"variable","annotations":{"framerContractVersion":"1"}},"distance":{"type":"variable","annotations":{"framerContractVersion":"1"}},"__FramerMetadata__":{"type":"variable"}}}
//# sourceMappingURL=./fuzzySearch.map